<feed xmlns="http://www.w3.org/2005/Atom"> <id>https://sirin0762.gitbub.io/</id><title>Sirin0762</title><subtitle>A minimal, portfolio, sidebar, bootstrap Jekyll theme with responsive web design and focuses on text presentation.</subtitle> <updated>2022-01-24T09:56:45+08:00</updated> <author> <name>sirin0762</name> <uri>https://sirin0762.gitbub.io/</uri> </author><link rel="self" type="application/atom+xml" href="https://sirin0762.gitbub.io/feed.xml"/><link rel="alternate" type="text/html" hreflang="en" href="https://sirin0762.gitbub.io/"/> <generator uri="https://jekyllrb.com/" version="4.2.1">Jekyll</generator> <rights> © 2022 sirin0762 </rights> <icon>/assets/img/favicons/favicon.ico</icon> <logo>/assets/img/favicons/favicon-96x96.png</logo> <entry><title>프로그래머스 점프와 순간이동 풀이</title><link href="https://sirin0762.gitbub.io/posts/prgrms12980/" rel="alternate" type="text/html" title="프로그래머스 점프와 순간이동 풀이" /><published>2022-01-24T09:47:29+08:00</published> <updated>2022-01-24T09:47:29+08:00</updated> <id>https://sirin0762.gitbub.io/posts/prgrms12980/</id> <content src="https://sirin0762.gitbub.io/posts/prgrms12980/" /> <author> <name>sirin0762</name> </author> <category term="algorithm" /> <category term="java" /> <summary> 문제 프로그래머스 점프와 순간 이동 내 생각 DP.. 라고 생각했다.. 그래서 bottom-top 방식으로 풀려고 하는데, dp방식으로 풀리지 않아서 답을 참조했다… 수학문제더라 하하… 이 문제는 N이 0이 될 때 까지, 짝수면 2로 나누고, 홀수면 -1을 하면 된다. 어찌됬는 순간이동을 하는게 가장 좋기 때문에 최우선순위를 순간이동으로 생각하고 풀어야하는 그리디 유형의 문제였다. 코드 이 코드는 dp로 풀려다가 망해버린 코드이다(추후 기억 복기용) 답안은 조금 더 아래에 있다. import java.util.*; public class Solution { int[] dp; public int solution(int n) { dp = new int[n + 1]; dp[1]... </summary> </entry> <entry><title>프로그래머스 영어 끝말잇기 풀이</title><link href="https://sirin0762.gitbub.io/posts/prgrms12981/" rel="alternate" type="text/html" title="프로그래머스 영어 끝말잇기 풀이" /><published>2022-01-21T07:04:29+08:00</published> <updated>2022-01-21T07:04:29+08:00</updated> <id>https://sirin0762.gitbub.io/posts/prgrms12981/</id> <content src="https://sirin0762.gitbub.io/posts/prgrms12981/" /> <author> <name>sirin0762</name> </author> <category term="algorithm" /> <category term="java" /> <summary> 문제 프로그래머스 영어 끝말잇기 링크 내 생각 hash를 이용하여 단어가 중복이 되었는지, 끝말잇기의 조건이 충족되는지를 확인하면서 배열을 순회하면 됩니다 코드 import java.util.*; class Solution { Map&amp;lt;String, String&amp;gt; map = new HashMap&amp;lt;&amp;gt;(); public int[] solution(int n, String[] words) { map.put(words[0], words[0]); for(int i = 1; i &amp;lt; words.length; i++) { int r = (i / n) + 1; int c = (i % ... </summary> </entry> <entry><title>프로그래머스 여행 경로 풀이</title><link href="https://sirin0762.gitbub.io/posts/prgrms43164/" rel="alternate" type="text/html" title="프로그래머스 여행 경로 풀이" /><published>2022-01-20T10:12:29+08:00</published> <updated>2022-01-20T12:55:25+08:00</updated> <id>https://sirin0762.gitbub.io/posts/prgrms43164/</id> <content src="https://sirin0762.gitbub.io/posts/prgrms43164/" /> <author> <name>sirin0762</name> </author> <category term="algorithm" /> <category term="java" /> <summary> 문제 프로그래머스 여행 경로 링크 내 생각 여행경로를 bfs를 통해서 q를 이용하되, 경로가 중복된다면 알파벳 순으로 정렬한뒤에 가장 앞에 있는 path를 넣어주는 방식 으로 했다. 허나 이 방식의 경우, 모든 경로를 들린다는 보장이 없기 때문에 모든 문제를 풀수 없었다. 그래서 다른 방법을 생각해야했다. dfs를 통해서 모든 경로를 탐색 한뒤, 그 경로를 정렬하여 가장 앞에있는 값을 리턴하면 됬다. 코드 bfs로 풀어보려다가 미국 가버린 코드입니다… 아래에 dfs를 통한 풀이를 참고하시면 감사하겠습니다. import java.util.*; class Path implements Comparable&amp;lt;Path&amp;gt;{ String start; String end; int... </summary> </entry> <entry><title>프로그래머스 음양 더하기 풀이</title><link href="https://sirin0762.gitbub.io/posts/prgrms76501/" rel="alternate" type="text/html" title="프로그래머스 음양 더하기 풀이" /><published>2022-01-19T10:45:29+08:00</published> <updated>2022-01-19T10:45:29+08:00</updated> <id>https://sirin0762.gitbub.io/posts/prgrms76501/</id> <content src="https://sirin0762.gitbub.io/posts/prgrms76501/" /> <author> <name>sirin0762</name> </author> <category term="algorithm" /> <category term="java" /> <summary> 문제 프로그래머스 음양 더하기 문제 링크 내 생각 부호가 true이냐, false이냐에 따라서 더하고 빼기를 해주면 된다. 코드 class Solution { public int solution(int[] absolutes, boolean[] signs) { int result = 0; for(int i = 0; i &amp;lt; signs.length; i++) { result += signs[i] ? absolutes[i] : -absolutes[i]; } return result; } } </summary> </entry> <entry><title>프로그래머스 프렌즈 4블록 풀이</title><link href="https://sirin0762.gitbub.io/posts/prgrms17679/" rel="alternate" type="text/html" title="프로그래머스 프렌즈 4블록 풀이" /><published>2022-01-19T10:37:29+08:00</published> <updated>2022-01-19T10:46:30+08:00</updated> <id>https://sirin0762.gitbub.io/posts/prgrms17679/</id> <content src="https://sirin0762.gitbub.io/posts/prgrms17679/" /> <author> <name>sirin0762</name> </author> <category term="algorithm" /> <category term="java" /> <summary> 문제 프로그래머스 프렌즈 4블록 문제 링크 답안 링크 내 생각 구현 문제이다. 다음과 같은 방식으로 풀이했지만, 실력 부족으로 3개의 테스트 케이스에서 시간초과가 떴다. 삭제할 블록을 체크한다. 체크한 블록을 삭제한다. 삭제된 공간에 블럭을 내린다. 반복한다. 답안과 논리는 같지만 구현실력에서 차이가 컸다. 당분간은 구현문제에 집중하려한다. 코드 import java.util.*; class Node { int x; int y; Node(int x, int y) { this.x = x; this.y = y; } } class Solution { char[][] map; int[] dx = {0, 1,... </summary> </entry> </feed>
